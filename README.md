# 方圆整理的高并发秒杀系统

## 1. 介绍
高并发秒杀系统实战项目，记录每一分成长

## 2. 软件架构

- flash-sale-domain: 领域层，包含实体类
- flash-sale-infrastructure: 基础设施层，包含mapper文件
- flash-sale-app: 应用层，包含service服务
- flash-sale-controller: controller层
- environment-mysql: 保存数据库脚本
- environment-postman: postman测试脚本

## 3. 分支说明

### 3.1 base-framework
- 想在这个分支搭建一个基础框架，什么项目代码都没有，能从这个分支上从0到1的开发

### 3.2 base-function
- 基础功能开发，包括秒杀活动的操作和秒杀品操作

---

### 用例分析

如图，因为系统用例很简单，所以只提取出三个关键概念：秒杀活动、秒杀商品和秒杀订单。如果是是更复杂的系统，秒杀活动可能是隶属于“活动”概念下的一个分类，针对商品和订单也是同样地道理，这样提炼出来的概念便是更加宽泛的概念：“活动”、“商品”和“订单”。

接下来需要做的就是明确概念的含义，这些含义将在日常需求沟通、产品文档和开发设计中体现：

| 概念   | Term          | 含义                          |
|------|---------------|-----------------------------|
| 秒杀活动 | flashActivity | 为达成拉新、留存和促销等业务进行的少量商品低价抢的活动 |
| 秒杀商品 | flashItem     | 针对秒杀活动创建的商品                 |
| 商品库存 | stock         | 秒杀商品的库存容量                   |
| 秒杀订单 | flashOrder    | 在秒杀活动下购买秒杀商品生成的订单           |

明确了这些概念之后，需要理清这些概念间的关系，并确定这些概念所代表的业务实体的核心属性和行为，从而得到概念模型。如下所示：



在我们当前的秒杀场景中，活动和品是 1:1 的关系，订单和品也是 1:1 的关系，并且订单和活动并没有直接关系。接下来需要根据概念模型划分子域，如下所示：



子域划分完成之后，我们需要让业务系统运转起来，那么便需要定义上下文映射，实现不同子域间的协作。秒杀活动域和秒杀订单域需要关联秒杀商品域，通过防腐层（ACL）来对接外部服务：



现在有了概念模型，便需要将其映射到代码层面的映射，定义实体、值对象和聚合根。我们先分别了解下相关概念：

- **实体**：实体是 **具有唯一标识符** 的对象，它们的生命周期可以通过其标识符来跟踪。实体的属性（比如状态）可能会发生变化，但其标识符保持不变
- **值对象**：没有唯一标识符的对象，其主要目的是描述某种属性或概念。值对象通常是不可变的
- **聚合根**：聚合根是特殊的实体，它是聚合的入口。聚合包含领域内一组相关的对象（实体与值对象等），作为一个整体对数据进行维护，在 **同一个聚合内满足业务一致性、数据完整性、状态一致性**

秒杀商品 `FlashItem` 将其定义成了聚合根，其中包含商品库存实体 `StockEntity` 和商品价格值对象 `ItemPrice`，商品售卖时库存发生变化；秒杀活动 `FlashActivity` 定义成了聚合根，秒杀活动的变更影响秒杀品的变更，比如秒杀活动结束，秒杀品状态变更为下架，在同一个聚合内保证它们的数据一致性；秒杀订单 `FlashOrder` 在我们的场景也定义成了聚合根，但是它并没有关联上其他需要保持数据一致性的实体，仅仅定义了商品快照信息 `ItemInfo` 值对象，通常情况下在较为复杂的领域它会关联修改相关实体。



---

### 应用服务

应用服务表象定位与 MVC 中的 Service 比较像，但是 Service 内部充满了功能点的逻辑处理，而应用服务相对来说是比较薄的一层，它只做逻辑编排。参数校验、聚合根方法调用、外部服务调用、持久化聚合根等与业务流程走向相关，业务逻辑无关的代码均可定义在此处。

### 仓储

领域模型是针对于业务层面的，而领域模型处理完业务之后需要通过数据层存储。数据层对应的是数据模型，为了桥接数据模型与领域模型，DDD 在战术设计中提出了仓储的概念。

仓储的定位就是持久化聚合与检索聚合。让应用服务专注逻辑编排，聚合根专注逻辑处理，不用关心领域模型的持久化方式与存储介质。

### 事件模型

比如下订单后，给用户增长积分与赠送优惠券的需求。如果在应用服务内实现，用户逻辑处理完，数据入库成功后，再依次调用用户增长积分的外部服务接口与赠送优惠券的外部服务接口。

到这里是不是很奇怪？我一个订单领域，已经把下订单这个事情做完了，但是却还要调用其他的三方服务的接口通知它们订单生成这个事情。如果后续通知的接口越来越多，对于应用服务简直就是灾难。

为了解决这个耦合严重的鸡肋点，DDD 的战术设计中提出了事件模型。下单完成后，发布一个下单完成的领域事件，让需要感知这个事件的服务自行监听并处理，忽略不相关的领域活动。

领域事件的发送成功应该与功能点的事务是一致的，但是领域事件的处理结果不应该与功能点事务一致。

我下订单成功了，发送了创建订单事件，但是积分增长失败了，这时如果让订单生成失败，这显然是不合理的。

### 架构分层

Domain 层不能依赖其他任何层，

依赖倒置。

六边形架构

在编排层（case）之下再抽象出来一层：能力层（ability），ability 层负责实现能力，目的是让 case 编排层只负责编排，不负责实现

在 DDD（领域驱动设计）中，ability 层是一种较新的概念，它位于服务编排层（应用服务层）和领域层之间，用于封装原子化的领域逻辑。以下是对 ability 层的总结以及为什么需要在服务编排层下再提出 ability 层：

#### ability 层概述

* **定义**： ability 层是 DDD 中的一种层，它封装了原子化的领域逻辑，这些逻辑通常由多个领域服务协同完成。
* **作用**： ability 层负责实现领域服务之间的协作，并对外提供简单的接口，使应用服务层可以轻松调用这些逻辑。
* **组成**：
    * **能力 (Ability)**: 代表一个原子化的领域逻辑，例如计算折扣、生成报告等。
    * **能力服务 (Ability Service)**: 负责实现能力，并对外提供接口。

#### 为什么需要 ability 层

1. **简化应用服务层**： 在某些情况下，领域服务可能需要执行复杂的逻辑，并涉及多个领域服务之间的协作。将这种复杂逻辑封装在 ability 层中，可以简化应用服务层的代码，使其更易于理解和维护。

2. **提高可重用性**： ability 层可以封装通用的领域逻辑，使其可以被多个应用服务层重用，从而提高代码的可重用性。

3. **隔离领域逻辑**： ability 层可以隔离领域逻辑，使其不受应用服务层变化的影响。这意味着，即使应用服务层的实现发生变化，只要 ability 层的接口保持不变，领域逻辑仍然可以正常工作。

4. **提高可测试性**： ability 层可以独立于领域层进行测试，这有助于提高测试覆盖率。

#### ability 层与服务编排层的关系

* **服务编排层**： 负责将领域服务组合在一起，以实现复杂的业务逻辑。
* **ability 层**： 负责封装原子化的领域逻辑，并提供简单的接口供服务编排层调用。

#### 总结

ability 层是 DDD 中一种用于封装原子化领域逻辑的层，它位于服务编排层和领域层之间。通过使用 ability 层，可以简化应用服务层的代码，提高代码的可重用性和可测试性，并隔离领域逻辑。虽然 ability 层是 DDD 中较新的概念，

另外关于订单中心中定义的 能力点，表示怀疑，对外的 RPC 调用是不是也封装在

应用层需要调用基础设施层的服务组件（如消息队列或加密解密服务等），但是并不是通过直接注入调用，而是借助“依赖倒置”，由领域层提供提供接口，基础设施层负责具体的实现。

领域层不依赖任何层，仅仅关注业务规则，不关注技术实现。
领域层对外的RPC调用接口定义成 XxxAdapter，使用适配器模式来防腐，不直接使用 RPC 接口返回的对象而是包装一层只取其中的对象，这样在依赖的接口发生变更时改动也很小。

应用层负责业务逻辑的编排和组合，同时也控制事务


### 领域服务

1. 领域服务之间允许互相调用；
2. 领域服务入参仅为基础变量（比如 String）或者聚合根。

### 仓储

第八节仓储讲的蛮好的

数据模型只存在于数据层，领域模型在领域层，而衔接了这两层的关键对象，就是仓储。

仓储所要做的就是让业务专注于自己的逻辑处理，防腐了数据模型变更对于领域模型的影响，让领域模型可以不受存储介质限制来定义业务属性，能够独立开展业务。


### 防腐



对外部系统的防腐：
防腐层又称适配层，用于转义内部上下文依赖的外部上下文。
我们认为一切外部服务所提供的能力或者模型都是不可靠的，我们如果要去使用这个能力，应该依赖本系统内的适配能力接口，由接口实现类去依赖外部服务与模型。
