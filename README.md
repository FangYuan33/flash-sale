

### 用例分析

如图，因为系统用例很简单，所以只提取出三个关键概念：秒杀活动、秒杀商品和秒杀订单。如果是是更复杂的系统，秒杀活动可能是隶属于“活动”概念下的一个分类，针对商品和订单也是同样地道理，这样提炼出来的概念便是更加宽泛的概念：“活动”、“商品”和“订单”。

接下来需要做的就是明确概念的含义，这些含义将在日常需求沟通、产品文档和开发设计中体现：

| 概念   | Term          | 含义                          |
|------|---------------|-----------------------------|
| 秒杀活动 | flashActivity | 为达成拉新、留存和促销等业务进行的少量商品低价抢的活动 |
| 秒杀商品 | flashItem     | 针对秒杀活动创建的商品                 |
| 商品库存 | stock         | 秒杀商品的库存容量                   |
| 秒杀订单 | flashOrder    | 在秒杀活动下购买秒杀商品生成的订单           |

明确了这些概念之后，需要理清这些概念间的关系，并确定这些概念所代表的业务实体的核心属性和行为，从而得到概念模型。如下所示：



在我们当前的秒杀场景中，活动和品是 1:1 的关系，订单和品也是 1:1 的关系，并且订单和活动并没有直接关系。接下来需要根据概念模型划分子域，如下所示：



子域划分完成之后，我们需要让业务系统运转起来，那么便需要定义上下文映射，实现不同子域间的协作。秒杀活动域和秒杀订单域需要关联秒杀商品域，通过防腐层（ACL）来对接外部服务：



现在有了概念模型，便需要将其映射到代码层面的映射，定义实体、值对象和聚合根。我们先分别了解下相关概念：

- **实体**：实体是 **具有唯一标识符** 的对象，它们的生命周期可以通过其标识符来跟踪。实体的属性（比如状态）可能会发生变化，但其标识符保持不变
- **值对象**：没有唯一标识符的对象，其主要目的是描述某种属性或概念。值对象通常是不可变的
- **聚合根**：聚合根是特殊的实体，它是聚合的入口。聚合包含领域内一组相关的对象（实体与值对象等），作为一个整体对数据进行维护，在 **同一个聚合内满足业务一致性、数据完整性、状态一致性**

秒杀商品 `FlashItem` 将其定义成了聚合根，其中包含商品库存实体 `StockEntity` 和商品价格值对象 `ItemPrice`，商品售卖时库存发生变化；秒杀活动 `FlashActivity` 定义成了聚合根，秒杀活动的变更影响秒杀品的变更，比如秒杀活动结束，秒杀品状态变更为下架，在同一个聚合内保证它们的数据一致性；秒杀订单 `FlashOrder` 在我们的场景也定义成了聚合根，但是它并没有关联上其他需要保持数据一致性的实体，通常情况下在较为复杂的业务场景下订单聚合会比较复杂。

### 架构分层

现在我们已经定义好了各个聚合对象，接下来需要在代码层面上做实现，首先我们先看一下架构分层设计，和大多数 DDD 架构设计类似，但也有所区别，如下所示：



#### 启动层（boot）

启动层比较简单，配置和拦截器都定义在这一层，在 `resources` 包括配置文件和静态文件。

#### 应用层（application）

应用层表象定位与 MVC 中的 `Service` 比较像，但是 `Service` 内部充满了业务功能的逻辑处理，而 DDD 中的应用层相对来说是比较薄的一层，它负责做 **事务控制和逻辑编排**。像参数校验、聚合根方法调用、外部服务调用等与业务逻辑无关的代码均可定义在此处。

#### 领域层（domain）

领域层是整个架构的核心，包含业务逻辑和业务规则。它由领域模型组成，直接反映业务的概念和流程。在该层中定义实体、聚合和值对象，采用充血模型的设计。领域层不依赖其它层，是独立于技术和基础设施的“业务”实现。

##### 仓储（repository）

领域模型是针对于业务层面的，而领域模型处理完业务之后需要通过数据层存储，数据层对应的是数据模型，为了 **桥接数据模型与领域模型**，DDD 在战术设计中提出了仓储的概念。仓储的定位就是持久化聚合与检索聚合，让应用服务专注逻辑编排，聚合根专注逻辑处理，并且防腐了数据模型变更对于领域模型的影响，让领域模型可以不受存储介质限制来定义业务属性，能够独立开展业务，不用关心领域模型的持久化方式与存储介质。

#### 基础设施层（infrastructure）

基础设施层提供技术支持，负责与外部系统和技术框架的集成，它实现了领域层和应用层所需的技术细节，以及 **实现了对外部系统的防腐（ACL）**。防腐在其他的一些 DDD 文章中又被称为防腐层，基础设施层在我们的设计中承担了这部分职责，防腐主要用于 **转义内部上下文依赖的外部上下文**。我们认为一切外部服务所提供的能力或者模型都是不可靠的，它们可能会发生变更。如果我们要去使用这个能力，并减小变更带来的影响范围，那么应该依赖本系统内的适配能力接口，由接口实现类去依赖外部服务与模型，以此来实现防腐，也体现了适配器模式。

### 事件模型

比如下订单后，给用户增长积分与赠送优惠券的需求。如果在应用服务内实现，用户逻辑处理完，数据入库成功后，再依次调用用户增长积分的外部服务接口与赠送优惠券的外部服务接口。

到这里是不是很奇怪？我一个订单领域，已经把下订单这个事情做完了，但是却还要调用其他的三方服务的接口通知它们订单生成这个事情。如果后续通知的接口越来越多，对于应用服务简直就是灾难。

为了解决这个耦合严重的鸡肋点，DDD 的战术设计中提出了事件模型。下单完成后，发布一个下单完成的领域事件，让需要感知这个事件的服务自行监听并处理，忽略不相关的领域活动。

领域事件的发送成功应该与功能点的事务是一致的，但是领域事件的处理结果不应该与功能点事务一致。

我下订单成功了，发送了创建订单事件，但是积分增长失败了，这时如果让订单生成失败，这显然是不合理的。


应用层需要调用基础设施层的服务组件（如消息队列或加密解密服务等），但是并不是通过直接注入调用，而是借助“依赖倒置”，由领域层提供提供接口，基础设施层负责具体的实现。

领域层不依赖任何层，仅仅关注业务规则，不关注技术实现。
领域层对外的RPC调用接口定义成 XxxAdapter，使用适配器模式来防腐，不直接使用 RPC 接口返回的对象而是包装一层只取其中的对象，这样在依赖的接口发生变更时改动也很小。

应用层负责业务逻辑的编排和组合，同时也控制事务

